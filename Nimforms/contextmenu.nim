
# contextmenu module - Created on 29-Apr-2023 16:45
# This module is included at the end of controls.nim

# const
    # TPM_LEFTBUTTON = 0x0000
    # TPM_RIGHTBUTTON = 0x0002
# 
# Class name - "Cmenu_Msg_Win"
let cmenuClsName : array[14, uint16] = [0x43, 0x6D, 0x65, 0x6E, 0x75, 0x5F, 0x4D, 0x73, 0x67, 0x5F, 0x57, 0x69, 0x6E, 0]
var cmenuMsgWinCreated : bool 
let cmnMsgWinClass = cast[LPCWSTR](cmenuClsName[0].addr)
let TPM_RETURNCMD : uint32 = 0x100



proc createMsgWindow(this: ContextMenu) # Forward declaration
proc getMenuItem(this: ContextMenu, idNum: uint32): MenuItem # Forward declaration

proc init(t: typedesc[ContextMenu]): ContextMenu =
    new(result)
    result.mHandle = CreatePopupMenu()
    result.mWidth = 120
    result.mHeight = 25
    result.mRightClick = true
    result.mDefBgBrush = newColor(0xe9ecef).makeHBRUSH()
    result.mHotBgBrush = newColor(0x90e0ef).makeHBRUSH()
    result.mBorderBrush = newColor(0x0077b6).makeHBRUSH()
    result.mGrayBrush = newColor(0xced4da).makeHBRUSH()
    result.mGrayCref = newColor(0x979dac).cref

proc newContextMenu*(parent: Control, menuNames: varargs[string, `$`]): ContextMenu =
    result = ContextMenu.init()
    result.mParent = parent    
    result.mFont = parent.mFont    
    result.createMsgWindow()
    if len(menuNames) > 0:
        for name in menuNames:
            let mtyp = if name == "|": mtContextSep else: mtContextMenu
            var mi = newMenuItem(name, mtyp, result.mHandle, result.mMenuCount)
            result.mMenuCount += 1
            result.mMenus[name] = mi
            # if mtyp == mtContextMenu:
            #     mi.insertMenuInternal(result.mHandle)
            #     result.mMenus[name] = mi
            # elif mtyp == mtSeparator:
            #     AppendMenuW(result.mHandle, MF_SEPARATOR, 0, nil)


proc newContextMenu*(parent: TrayIcon, menuNames: varargs[string, `$`]): ContextMenu =
    result = ContextMenu.init()
    result.mTray = parent 
    result.mTrayParent = true   
    result.mFont = newFont("Tahoma", 11, autoc = true)    
    
    if len(menuNames) > 0:
        for name in menuNames:
            let mtyp = if name == "|": mtContextSep else: mtContextMenu
            var mi = newMenuItem(name, mtyp, result.mHandle, result.mMenuCount)
            result.mMenuCount += 1
            result.mMenus[name] = mi


proc cmenuDtor(this: ContextMenu) =
    DeleteObject(this.mHotBgBrush)
    DeleteObject(this.mBorderBrush)
    DeleteObject(this.mGrayBrush)
    DeleteObject(this.mDefBgBrush)
    if len(this.mMenus) > 0:
            for key, menu in this.mMenus: menu.menuItemDtor()
            
    DestroyMenu(this.mHandle)
    # echo "Context menu destroy worked"


proc addSubMenu*(this: ContextMenu, parenttext: string, menutext: string): MenuItem {.discardable.} =
    var parent : MenuItem = this.mMenus[parenttext]
    parent.mHandle = CreatePopupMenu()
    parent.mPopup = true
    let mtyp = (if menutext == "|": mtContextSep else: mtContextMenu)
    result = newMenuItem(menutext, mtyp, parent.mHandle, parent.mMenuCount)
    parent.mMenuCount += 1
    parent.mMenus[menutext] = result


# This proc will get called right before context menu showed
proc cmenuInsertItem(this: MenuItem) =
    if len(this.mMenus) > 0:
        for key, menu in this.mMenus:
            menu.cmenuInsertItem()
    # echo "menu: ", this.mText, ", type: ", this.mType
    if this.mType == mtContextMenu:
        this.insertMenuInternal(this.mParentHandle)
    elif this.mType == mtContextSep:
        AppendMenuW(this.mParentHandle, MF_SEPARATOR, 0, nil)


# This proc will get called right before context menu showed
proc cmenuCreateHandle(this: ContextMenu) =
    if len(this.mMenus) > 0:
        for key, menu in this.mMenus:
            menu.cmenuInsertItem()
        #}
    #}
    this.mMenuInserted = true


proc showMenu(this: ContextMenu, lpm: LPARAM) =
    # Create the message-only window and close it when proc exits.
    this.createMsgWindow()
    defer: DestroyWindow(this.mDummyHwnd)
    if not this.mMenuInserted: this.cmenuCreateHandle()

    var pt : POINT
    getMousePos(&pt, lpm)

    # ContextMenu message sometimes generated by keybord shortcuts.
    # In such caes points must be -1. So we need to find the mouse position.
    if pt.x == -1 or pt.y == -1: pt = getMousePosOnMsg()

    # If tray icon is going to show context menu, we need to activate
    # the tray icon's hidden window. Otherwise, we didn't get the keyboard focus.
    if this.mTray != nil: SetForegroundWindow(this.mTray.mMsgHwnd)

    # We are using TPM_RETURNCMD in the tpm_flag, so we don't get the 
    # WM_COMMAND in our wndproc, we will get the selected menu id in return value.
    let mid = cast[uint32](TrackPopupMenu(this.mHandle, TPM_RETURNCMD, pt.x, pt.y, 0, this.mDummyHwnd, nil))

    # Now, we have the menu id and we can process the menu.onClick event.
    if mid > 0:
        var menu = this.getMenuItem(mid)
        if menu != nil and menu.mIsEnabled:
            if menu.onClick != nil: menu.onClick(menu, newEventArgs())
#--------------------------------------------------------------------------


proc menus*(this: ContextMenu): Table[string, MenuItem] = return this.mMenus


proc `[]`*(this: ContextMenu, key: string): MenuItem = 
    # for k, menu in this.mMenus:
    #     if menu.mText == key:
    #         return menu
    result = this.mMenus[key]


proc cmenuWndProc( hw: HWND, msg: UINT, wpm: WPARAM, lpm: LPARAM): LRESULT {.stdcall.}


proc createMsgWindow(this: ContextMenu) =
    if not cmenuMsgWinCreated:
        registerMessageWindowClass(cmnMsgWinClass, cmenuWndProc)
        cmenuMsgWinCreated = true

    this.mDummyHwnd = CreateWindowExW(0, cmnMsgWinClass, nil, 0, 0, 0, 0, 0, 
                                        HWND_MESSAGE, nil, appData.hInstance, nil)
    if this.mDummyHwnd != nil:
        SetWindowLongPtrW(this.mDummyHwnd, GWLP_USERDATA, cast[LONG_PTR](cast[PVOID](this)))


proc getMenuItem(this: ContextMenu, idNum: uint32): MenuItem =
    for key, menu in this.mMenus:
        if menu.mId == idNum: return menu


proc cmenuWndProc( hw: HWND, msg: UINT, wpm: WPARAM, lpm: LPARAM): LRESULT {.stdcall.} =
    case msg
    of WM_DESTROY:
        echo "Conetxt menu message-only window destroyed"

    of WM_MEASUREITEM:
        var this  = cast[ContextMenu](GetWindowLongPtrW(hw, GWLP_USERDATA))
        var pmi = cast[LPMEASUREITEMSTRUCT](lpm)
        pmi.itemWidth = UINT(this.mWidth)
        pmi.itemHeight = UINT(this.mHeight)
        return 1

    of WM_DRAWITEM:
        var this  = cast[ContextMenu](GetWindowLongPtrW(hw, GWLP_USERDATA))
        var dis = cast[LPDRAWITEMSTRUCT](lpm)
        var mi = cast[MenuItem](cast[PVOID](dis.itemData))
        var txtClrRef : COLORREF = mi.mFgColor.cref

        if (dis.itemState and 1) == 1:
            # var rc : RECT
            if mi.mIsEnabled:
                let rc = RECT(left: dis.rcItem.left + 4, top: dis.rcItem.top + 2,
                              right: dis.rcItem.right, bottom: dis.rcItem.bottom - 2)
                FillRect(dis.hDC, rc.unsafeAddr, this.mHotBgBrush)
                FrameRect(dis.hDC, rc.unsafeAddr, this.mBorderBrush)
                txtClrRef = 0x00000000
            else:
                FillRect(dis.hDC, dis.rcItem.unsafeAddr, this.mGrayBrush)
                txtClrRef = this.mGrayCref
        else:
            FillRect(dis.hDC, dis.rcItem.unsafeAddr, this.mDefBgBrush)
            if not mi.mIsEnabled: txtClrRef = this.mGrayCref

        SetBkMode(dis.hDC, 1)
        dis.rcItem.left += 25
        SelectObject(dis.hDC, this.mFont.handle)
        SetTextColor(dis.hDC, txtClrRef)
        DrawTextW(dis.hDC, mi.mWideText, -1, dis.rcItem.unsafeAddr, DT_LEFT or DT_SINGLELINE or DT_VCENTER)
        return 0

    of WM_ENTERMENULOOP:
        var this  = cast[ContextMenu](GetWindowLongPtrW(hw, GWLP_USERDATA))
        if this.onMenuShown != nil: this.onMenuShown(this.mParent, newEventArgs())

    of WM_EXITMENULOOP:
        var this  = cast[ContextMenu](GetWindowLongPtrW(hw, GWLP_USERDATA))
        if this.onMenuClose != nil: this.onMenuClose(this.mParent, newEventArgs())

    of WM_MENUSELECT:
        var this  = cast[ContextMenu](GetWindowLongPtrW(hw, GWLP_USERDATA))
        let idNum = uint32(LOWORD(wpm))
        let hMenu = cast[HMENU](lpm)
        if hMenu != nil and idNum > 0:
            var menu = this.getMenuItem(idNum)
            if menu != nil and menu.mIsEnabled:
                if menu.onFocus != nil: menu.onFocus(menu, newEventArgs())

    # of WM_COMMAND:
    #     var this  = cast[ContextMenu](GetWindowLongPtrW(hw, GWLP_USERDATA))
    #     let idNum = uint32(LOWORD(wpm))
    #     if idNum > 0:
    #         var menu = this.getMenuItem(idNum)
    #         if menu != nil and menu.mIsEnabled:
    #             if menu.onClick != nil: menu.onClick(menu, newEventArgs())
    
    else: return DefWindowProcW(hw, msg, wpm, lpm)
    return DefWindowProcW(hw, msg, wpm, lpm)

    


